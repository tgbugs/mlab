from database.imports import *
from database.models.base import Base
from database.models.mixins import HasNotes, HasMetaData, HasDataFiles, HasHardware


###-----------------------
###  Subject Base
###-----------------------

#TODO make sure that generating experiment and experiments are fine to be the same experiment
#FIXME if subjects have data about them and are generate by the same experiment there will be an infinite loop
class Subject(HasMetaData, AssociatedDataFileSource, HasDataFile, HasHardware, HasNotes, Base):
    __tablename__='subjects'
    id=Column(Integer,primary_key=True)
    type=Column(String,nullable=False)


    #whole-part relationships for all subjects
    parent_id=Column(Integer,ForeignKey('subjects.id'))
    children=relationship('Subject',primaryjoin='Subject.id==Subject.parent_id',backref=backref('parent',uselist=False,remote_side=[id]))

    #experiment in which the subject was generated (eg a mating, or a slice prep)
    generating_experiment_id=Column(Integer,ForeignKey('experiments.id'))
    generating_experiment=relationship('Experiment',backref=backref('generated_subjects'),uselist=False)

    #generative relationships, some are being preserving others are terminal (binary fision anyone?)
    generated_from_subjects=relationship('Subject',secondary='experiments_subjects',
            primaryjoin='Subject.generating_experiment_id==experiments_subjects.c.experiments_id',
            secondaryjoin='Subject.id==experiments_subjects.c.subjects_id', #FIXME this is the problem
            backref='generated_subjects')
    #FIXME under this construction subjects that are generated by an experiment and have data about them cause errors
    #SOLUTION? maybe some subjects are more like reagents for certain experiments so input_subjects? could handle it that way in Experiment?
    #data containing subjects vs 'used' subjects
    #could also just leave off geid when they are enerated by the experiment where they are data subjects...

    #identified groups connector
    group_id=Column(Integer,ForeignKey('subjectcollection.id')) #FIXME fuck, m-m on this? :/ subjects *could* belong to mupltiple identified groups, for example the jim group and the jeremy group

    #datetime data birth/death, time on to right/ time out of rig etc
    #other time points are probably actually metadata bools
    startDateTime=Column(DateTime,default=datetime.now)
    sDT_abs_error=Column(Interval)
    endDateTime=Column(DateTime)

    @property
    def rootParent(self): #FIXME probably faster to do this with a func to reduce queries
        if self.parent:
            return parent.getRootParent()
        else:
            return self

    @property
    def lastChildren(self,allChilds=[]):
        if not allChilds and self.children:
            return lastChildren(self.children)
        else:
            new_allChilds=[]
            for child in allChilds:
                try:
                    new_allChilds.extend(child.children)
                except:
                    pass
            if not new_allChilds[]:
                return allChilds
            return lastChildren(new_allChilds)

    @validates('parent_id','generating_experiment_id','startDateTime','sDT_abs_error','endDateTime')
    def _wo(self, key, value): return self._write_once(key, value)


    __mapper_args__ = {
        'polymorphic_on':type,
        'polymorphic_identity':'subject',
    }

    def nthChildren(self,n,allChilds=[]):
        if n:
            if not allChilds and self.children:
                return nthChildren(n-1,self.children)
            else:
                new_allChilds=[]
                for child in allChilds:
                    try:
                        new_allChilds.extend(child.children)
                    except:
                        pass
                return nthChildren(n-1,new_allChilds)
        else:
            return allChilds

    def __init__(self,Parent=None,GeneratingExperiment=None,startDateTime=None,
            sDT_abs_error=None,Experiments=[],Hardware=[],
            parent_id=None,generating_experiment_id=None):

        self.parent_id=parent_id
        self.generating_experiment_id=generating_experiment_id
        self.startDateTime=startDateTime
        self.sDT_abs_error=sDT_abs_error

        self.experiments.extend(Experiments)
        self.hardware.extend(Hardware)

        if Parent:
            if Parent.id:
                self.parent_id=parent_id
            else:
                raise AttributeError
        if GeneratingExperiment:
            if GeneratingExperiment.id:
                self.generating_experiment=GeneratingExperiment.id
            else:
                raise AttributeError


class ArbitrarySubjectCollection(Base): #TODO m-m probably should just make a 'HasArbitraryCollections' mixin
    id=Column(Integer,primary_key=True)
    name=Column(String(30),nullable=False)


class SubjectCollection(Subject):
    """Identified collections of subjects that have no physical form in themselves yet are still subjects and can generate subjects"""
    __tablename__='subjectcollection'
    id=Column(Integer,ForeignKey('subjects.id'),primary_key=True)
    name=Column(String(30),nullable=False)
    members=relationship('Subject',primaryjoin='Subject.parent_id==SubjectCollection.id',backref=backref('group',uselist=False))

    @validates('generating_experiment_id','startDateTime','sDT_abs_error')
    def _wo(self, key, value): return self._write_once(key, value)

    @property
    def remaining(self):
        return [m for m in self.members if not m.endDateTime]

    @property
    def size(self): #FIXME just use len??
        return len(self.members)

    def __len__(self):
        return len(self.members)

    def __init__(self,Parent=None,GeneratingExperiment=None,name=None,
            startDateTime=None,sDT_abs_error=None,Members=[],Experiments=[],
            Hardware=[],parent_id=None,generating_experiment_id=None):

        super().__init__(Parent=Parent,GeneratingExperiment=GeneratingExpeirment,
                startDateTime=startDateTime,sDT_abs_error=sDT_abs_error,
                Experiments=Experiments,Hardware=Hardware,parent_id=parent_id,
                generating_experiment_id=generating_experiment_id)

        self.name=name
        self.members.extend(Members)

###-----------------------
###  Subjects
###-----------------------

class Mouse(Subject):
    __tablename__='mouse'
    id=Column(Integer,ForeignKey('subjects.id'),primary_key=True,autoincrement=False)

    eartag=Column(Integer)
    tattoo=Column(Integer)
    name=Column(String(20))  #words for mice

    #cage and location information
    cage_id=Column(Integer,ForeignKey('cage.id')) #the cage card number

    sex_id=Column(String(1),ForeignKey('sex.abbrev'),nullable=False)

    strain_id=Column(Integer,ForeignKey('strain.id')) #phylogeny of strains shall be handled in its own table

    __mapper_args__ = {'polymorphic_identity':'mouse'}

    @property
    def age(self):
        if self.endDateTime:
            return self.endDateTime-self.startDateTime #FIXME uncertainty
        else:
            return datetime.now()-self.startDateTime #uncertainty plox
        
    @property
    def breedingRecs(self):
        return [e for e in self.experiments if e.type.name=='mating record']

    def __init__(self,Parent=None,GeneratingExperiment=None,startDateTime=None,
            sDT_abs_error=None,eartag,tattoo=None,name=None,sex_id=None,
            strain_id=None,cage_id=None,Experiments=[],Hardware=[],
            parent_id=None,generating_experiment_id=None):

        super().__init__(Parent=Parent,GeneratingExperiment=GeneratingExpeirment,
                startDateTime=startDateTime,sDT_abs_error=sDT_abs_error,
                Experiments=Experiments,Hardware=Hardware,parent_id=parent_id
                generating_experiment_id=generating_experiment_id)

        self.eartag=eartag
        self.tattoo=tattoo
        self.num=num
        self.name=name

        self.cage_id=cage_id

        self.sex_id=sex_id
        self.strain_id=strain_id
    
    def __repr__(self):
        base=super().__repr__()
        try:
            litter=self.litter.strHelper(1)
        except:
            litter='\n\tLitter None'
        try:
            breedingRec=self.breedingRec.strHelper(1)
        except:
            breedingRec='\n\tBreedingRec None'

        return base+'%s %s %s'%(self.dob.strHelper(1),litter,breedingRec)


class Slice(Subject): #FIXME slice should probably be a subject
    __tablename__='slice'
    id=Column(Integer,ForeignKey('subjects.id'),primary_key=True) #FIXME

    @property
    def dateTimeOut(self):
        exp=self.experiments[0]
        return exp.endDateTime

    @property
    def thickness(self):
        return [m for m in self.experiments[0].metadata_ if m.metadatasource.name=='trmSliceThickness'][0] #FIXME this ok?

    __mapper_args__ = {'polymorphic_identity':'slice'}


class Cell(Subject):
    __tablename__='cell'
    id=Column(Integer,ForeignKey('subjects.id'),primary_key=True,autoincrement=False)
    __mapper_args__={'polymorphic_identity':'cell'}

    def __repr__(self):
        base=super().__repr__()
        return '%s%s%s%s'%(base,''.join([h.strHelper(1) for h in self.hardware]),self.parent.strHelper(1),''.join([c.strHelper(1) for c in self.datafiles[0].subjects]))


#FIXME the binding between data and subjects is really fucking tenuous sometimes... :/
#FIXME think about whether we really want to bind subjects to hardware, that seems... strange???
class HardwareSubject(Subject): #TODO we can make this ObjectSubject and bind anything we want to a subject without having to do crazy shit with Hardware-Hardware interactions and stuff like that since most hardware doesn't have generation experiments
    """Class used to represent hardware as a subject for calibration"""
    #hell, chemistry is just a bunch of reagent subjects...
    #this DOES mean that I will need to come up with a way of associating subjects/people/hardware to MDSes in a transient way but still keep records, this is one of those things that fluctuates more slowly
    __tablename__='hardwaresubject'
    id=Column(Integer,ForeignKey('subjects.id'),primary_key=True,autoincrement=False)
    hardware_id=Column(Integer,ForeignKey('hardware.id'),nullable=False,unique=True)
    hardware=relationship('Hardware',uselist=False) #FIXME hw-sub relationships are now fucking insane
    __mapper_args__={'polymorphic_identity':'hardware'}
    def __init__(self,Hardware=None,Parent=None,GeneratingExperiment=None,startDateTime=None,
            sDT_abs_error=None,Experiments=[],
            parent_id=None,generating_experiment_id=None):

        super().__init__(GeneratingExperiment=GeneratingExpeirment,
                startDateTime=startDateTime,sDT_abs_error=sDT_abs_error,
                Experiments=Experiments,generating_experiment_id=generating_experiment_id)

        self.hardware_id=hardware_id

        if Hardware:
            if Hardware.id:
                self.hardware_id=Hardware.id
            else:
                raise AttributeError
