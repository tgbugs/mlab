from database.imports import *
from database.models.base import Base
from database.models.mixins import HasNotes, HasMetaData, HasDataFiles, HasHardware, HasExperiments, HasProperties, HasSwcHwRecords, HasTreeStructure


###-----------------------
###  Subject Base
###-----------------------

class SubType(): #FIXME not sure if this is a good replacement for strain or not...
    #awe yeah type token
    id=Column(Integer,primary_key=True)
    parenttype_id=Column(Integer,ForeignKey('subtype.id'))
    subtypes=relationship('SubType',primaryjoin='SubType.id==SubType.parenttype_id',backref=backref('parenttype',uselist=False,remote_side=[id])) #AARRRGGGGGG not the most helpful way to do this >_<


class SubjectType(Base): #XXX not using, favoring use of STE so we can have nice python properties
    #id=Column(Integer,primary_key=True) #FIXME may not need this
    #name=Column(String,nullable=False,unique=True)
    id=Column(String,primary_key=True)
    subjects=relationship('Subject',primaryjoin='Subject.type_id==SubjectType.id',backref=backref('type',uselist=False))
    has_sexual_ontogeny=Column(Boolean,default=False)
    #reference_type=None #might be a way to add something like HardwareSubject??? may need the mixin for that and just have the mixin define the type by the table name
    #better to use HasMetaData, HasFiles, etc than to make stuff subjects... maybe change to 'HasExperiments'
    #true it is not as explicit...
    def __str__(self):
        return id
    def __init__(self,id,has_sex=None):
        self.id=id
        self.has_sexual_ontogeny=has_sex


#TODO make sure that generating experiment and experiments are fine to be the same experiment
#FIXME if subjects have data about them and are generate by the same experiment there will be an infinite loop
#TODO TODO the best way to associate hardware to a subject is NOT by direcly linking the subject to the hardware, becuase that can change, but using the hardware present at that time with it's associated datafilesource (or the like) and associating the subject to THAT sub structure
class Subject(HasMetaData, HasDataFiles, HasSwcHwRecords, HasExperiments, HasProperties, HasHardware, HasNotes, HasTreeStructure, Base):
    __tablename__='subjects'
    id=Column(Integer,primary_key=True)
    type_id=Column(String,ForeignKey('subjecttype.id'),nullable=False)

    #whole-part relationships for all subjects
    parent_id=Column(Integer,ForeignKey('subjects.id'))
    children=relationship('Subject',primaryjoin='Subject.id==Subject.parent_id',backref=backref('parent',uselist=False,remote_side=[id]))

    #imagine you could patch the same cell multiple times with different headstages, what would be needed
    #or hell, the same cell with multiple headstages (some serious assertions here wrt dendrite patching)
    #FIXME HasHardware needs to be mutable and work on a single experiment basis

    #experiment in which the subject was generated (eg a mating, or a slice prep)
    generating_experiment_id=Column(Integer,ForeignKey('experiments.id'))
    generating_experiment=relationship('Experiment',backref=backref('generated_subjects'),uselist=False)

    #generative relationships, some are being preserving others are terminal (binary fision anyone?)
    #FIXME if parent_id is None then we can use this???? maybe a bit too much overlap?
    #ontogeny vs part-whole
    generated_from_subjects=relationship('Subject',secondary='subjects_experiments',
            primaryjoin='Subject.generating_experiment_id==subjects_experiments.c.experiments_id',
            secondaryjoin=( 'and_(Subject.id==subjects_experiments.c.subjects_id,'
                            ')' ), #FIXME this is the problem
            backref='generated_subjects')
    #FIXME under this construction subjects that are generated by an experiment and have data about them cause errors
    #SOLUTION? maybe some subjects are more like reagents for certain experiments so input_subjects? could handle it that way in Experiment?
    #data containing subjects vs 'used' subjects
    #could also just leave off geid when they are enerated by the experiment where they are data subjects...

    #identified groups connector
    #XXX NOTE XXX we do NOT need this for subjectcollection because generating_parent_id props via exp
    group_id=Column(Integer,ForeignKey('subjectgroup.id',use_alter=True,name='sg_fk')) #FIXME fuck, m-m on this? :/ subjects *could* belong to mupltiple identified groups, for example the jim group and the jeremy group
    location_id=Column(Integer,ForeignKey('locations.id'))

    #datetime data birth/death, time on to right/ time out of rig etc
    #other time points are probably actually metadata bools
    startDateTime=Column(DateTime,default=datetime.now)
    sDT_abs_error=Column(Interval)
    endDateTime=Column(DateTime)

    #variables for running experiments #FIXME move to protocol
    paramNames=tuple #persistable values that are not filled in at init
    preStepNames=tuple
    interStepNames=tuple
    postStepNames=tuple
    child_type=Base #FIXME?

    #@validates('parent_id','generating_experiment_id','startDateTime','sDT_abs_error','endDateTime')
    @validates('generating_experiment_id','startDateTime','sDT_abs_error','endDateTime') #FIXME FIXME
    def _wo(self, key, value): return self._write_once(key, value)

    @validates('properties') #FIXME validates only works on actual values in the table
    def _has_sex(self, key, value): #FIXME set this flag under subject type? 'has sexual ontogeny'
        if self.type.has_sexual_ontogney:
            try:
                sex_id=getattr(self,key)['sex']
            except:
                raise AttributeError('Mice must have a sex property! pass {\'sex\':\'m\'} or f or u to Properties')
            if sex_id not in ('m','f','u'): #FIXME god damn it not using the constrains w/in the database for this
                #is this the cost of becoming too general? I end up reimplementing the functionality of ForeignKeys
                raise AttributeError('acceptable sex values are m f or u')
            return value
        else:
            return value

    __mapper_args__ = {
        'polymorphic_on':type_id,
        'polymorphic_identity':'subject',
    }

    def __init__(self,parent_id=None,generating_experiment_id=None,
            group_id=None,startDateTime=None,sDT_abs_error=None,
            Experiments=[],Hardware=[],Properties={}):
        if self.type_id is 'subject':
            raise NotImplementedError('You shouldn\'t add undefined subjects to the database!')

        #FIXME there might be a way to do this with try:except
        if parent_id:
            #printD(self.parent_id)
            self.parent_id=int(parent_id) #FIXME could lead to some hard to follow errors... raise earlier?
        if generating_experiment_id:
            self.generating_experiment_id=int(generating_experiment_id)
        if group_id:
            self.group_id=int(group_id)
        self.startDateTime=startDateTime
        self.sDT_abs_error=sDT_abs_error

        self.experiments.extend(Experiments)
        self.hardware.extend(Hardware)
        self.properties.update(Properties)
        #[self.Properties(self,key,value) for key,value in Properties.items()]


class SubjectGroup(Base): #TODO m-m probably should just make a 'HasArbitraryCollections' mixin
    id=Column(Integer,primary_key=True)
    name=Column(String(30),nullable=False)
    parent_id=Column(Integer,ForeignKey('subjects.id',use_alter=True,name='sub_fk')) #FIXME this won't join to children...
    parent=relationship('Subject',primaryjoin='Subject.id==SubjectGroup.parent_id',backref=backref('subgroups'),uselist=False) #URG this feels REALLY ugly
    members=relationship('Subject',primaryjoin='and_(Subject.group_id==SubjectGroup.id,Subject.parent_id==SubjectGroup.parent_id)') #m-m?

    def __len__(self):
        return len(self.members)


###----------------------------------------------------------
### Subject Mixins  These are ONLY for ForeignKey columns !!!
###----------------------------------------------------------

class UsesJTI:
    """ Mixin for making new Subject classes that have their own columns
        TODO/FIXME should all other mixins inherit from JTISubject automatically?

        By default __tablename__=cls.__name__.lower()+'s' so if the plural of mouse is not mouses
        and that bothers you set __tablename__ manually

        By default __mapper_args__={'polymorphic_identity':cls.__name__.lower()} to override
        set __mapper_args__ manually and to extend mapper args use __mapper_args__.update({})
    """
    @declared_attr
    def __tablename__(cls):
        return cls.__name__.lower()+'s'
    @declared_attr
    def id(cls):
        super_id=super().__tablename__
        #printD(super_id)
        return Column(Integer,ForeignKey('%s.id'%super_id),primary_key=True)
    @declared_attr
    def __mapper_args__(cls):
        return {'polymorphic_identity':cls.__name__.lower()} #FIXME
    #__mapper_args__ = {'polymorphic_identity':type_string}


class HasSex(UsesJTI):
    @declared_attr
    def sex_id(cls):
        return Column(String(1),ForeignKey('sex.abbrev'),nullable=False)

    @property
    def sire(self):
        return [m for m in self.generated_from_subjects if m.sex_id == 'm'][0]
    @property
    def dam(self):
        return [m for m in self.generated_from_subjects if m.sex_id == 'f'][0]
    @declared_attr
    def sire(cls): #TODO
        pass
        #cn=cls.__name__
        #return relationship('%s'%cn,primaryjoin='',secondaryjoin='',uselist=False)
    @property
    def breedingRecs(self):
        return [e for e in self.experiments if e.type.name=='Mating Record'] #FIXME does this go here?
    def __init__(self,**kwargs): #FIXME how to do this cooperatively
        self.sex_id=str(sex_id)

class HasGeneratingExperiment(UsesJTI):
    #all subjects may have this...
    pass

class HasGenetics(UsesJTI):
    @declared_attr
    def strain_id(cls):
        return Column(Integer,ForeignKey('strain.id'),nullable=False)
    #something to track the measured genotype and make sure it matches
    @property
    def somethingYouDoWithStrain(self):
        return None
    def __init__(self,**kwargs):
        self.strain_id=int(strain_id)

class HasLocation(UsesJTI):
    @declared_attr
    def location_id(cls):
        return Column(Integer,ForeignKey('locations.id'))
    def __init__(self,**kwargs):
        if location_id is not None:
            self.location_id=int(location_id)

#FIXME Mixins MUST Implement ForeignKey constraints otherwise they should not be a mixin

###---------------------------------------------------------------------------------
###  Subjects THOU SHALT NOT USE THESE FOR QUERYING only for creation and post query
###---------------------------------------------------------------------------------

class NewSubjectType(UsesJTI, Subject):
    pass

class Litter(UsesJTI, Subject):
    @property
    def remaining(self):
        return [m for m in self.members if not m.endDateTime]
    @property
    def size(self): #FIXME just use len??
        return len(self.children)
    def __len__(self):
        return len(self.children)


class Mouse(HasSex, HasGenetics, HasLocation, Subject):
    #FIXME  some way to add rows to SubjectType automatically?
    #TODO consider using 'include_properties':[] and/or 'exclude_properties':[]
    __tablename__='mice'
    @property
    def age(self):
        if self.endDateTime:
            return self.endDateTime-self.startDateTime #FIXME uncertainty
        else:
            return datetime.now()-self.startDateTime #uncertainty plox
    def __init__(self,**kwargs):
        super().__init__(**kwargs)


class Slice(UsesJTI, Subject): #FIXME slice should probably be a subject
    @property
    def dateTimeToRig(self): #FIXME is the how I want to do this... I could do this via type...?
        return self.startDateTime
    @property
    def dateTimeOut(self): #FIXME well, since I can't do that, how do I persist THIS (in type??)
        exp=self.generating_experiment
        return exp.endDateTime
    @property
    def thickness(self):
        return [m for m in self.experiments[0].metadata_ if m.metadatasource.name=='trmSliceThickness'][0] #FIXME this ok?


class Cell(UsesJTI, Subject):
    pass
    #def __repr__(self):
        #base=super().__repr__()
        #return base
        #return '%s%s%s%s'%(base,''.join([h.strHelper(1) for h in self.hardware]),self.parent.strHelper(1),''.join([c.strHelper(1) for c in self.datafiles[0].subjects]))


class HardwareSubject(UsesJTI, Subject): #TODO we can make this ObjectSubject and bind anything we want to a subject without having to do crazy shit with Hardware-Hardware interactions and stuff like that since most hardware doesn't have generation experiments
    """Class used to represent hardware as a subject for calibration"""
    #hell, chemistry is just a bunch of reagent subjects...
    #this DOES mean that I will need to come up with a way of associating subjects/people/hardware to MDSes in a transient way but still keep records, this is one of those things that fluctuates more slowly
    hardware_id=Column(Integer,ForeignKey('hardware.id'),nullable=False,unique=True) #FIXME
    hardware=relationship('Hardware',backref=backref('data_records',uselist=False),uselist=False) #FIXME hw-sub relationships are now fucking insane
    __mapper_args__={'polymorphic_identity':'hardware'}
    def __init__(self,hardware_id,parent_id=None,generating_experiment_id=None,
            group_id=None,startDateTime=None,sDT_abs_error=None,
            Experiments=[],Hardware=[]):

        super().__init__(parent_id=parent_id,generating_experiment_id=generating_experiment_id,
            group_id=group_id,startDateTime=startDateTime,sDT_abs_error=sDT_abs_error,
            Experiments=[],Hardware=[]) #Hardware=[] : somewhere down there there is a sliderule

        self.hardware_id=int(hardware_id)

class Sample(UsesJTI, Subject):
    #does this pattern work for samples taken from cytoplasm?
    #it is generated by an experiment
    #it will probably have data associated with it at some point...
    #looking good...
    #it will have a literal part-whole parent and a generating subject that are the same...
    pass
